# Chapter 1. 자바 8, 9, 10, 11: 무슨 일이 일어나고 있는가?

<br>

## 1.1 역사의 흐름은 무엇인가?

**자바 8 → 자바 역사를 통틀어 가장 큰 변화가 일어난 버전**

자바 9 에서도 중요한 변화가 있었으나 자바 8만큼 획기적이거나, 생산성에 큰 영향을 미치지는 않았고, 자바 10 에서는 형 추론과 관한 약간의 변화만 일어났을 뿐이다.

자바 8 의 변화를 통해 코드의 생산성이 향상되었다고 하였는데, 어떤 식으로 생산성이 늘어났는지 예시를 하나 봐보자.  

한 반의 학생들을 성적순으로 정렬하고자 할 때, 자바 8 이전과 자바 8 이후에 각각 어떤 식으로 이 기능을 구현할 수 있을까?

- **자바 8 이전**
    
    ```java
    Collections.sort(students, new Comparator<Student>() {
    		public int compare(Student s1, Student s2) {
    				return s1.getGrade().compareto(s2.getGrade());
    		}
    }
    ```
    

- **자바 8 이후**
    
    ```java
    students.sort(comparing(Student::getGrade));
    ```
    

한 눈에 봐도 코드가 상당히 간결해진 것을 볼 수 있다. 간단하면서도 축약된 코드로 동일한 기능을 구현할 수 있다니 상당히 매력적이다.

이 외에도 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다. 

<br>
<aside>

**❗️즉 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용 이 두 가지 요구사항을 기반으로 한다.**

</aside>
<br>

자바 8에서 제공하는 새로운 기술 몇 가지를 언급하고 넘어가자.

1. **스트림 API**
2. **메소드에 코드를 전달하는 기법**
3. **인터페이스와 디폴트 메소드**

이 세가지가 자바 8에서 제공하는, 핵심적인 기술들이다.

자바 8은 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼, 병렬 연산을 지원하는 **스트림** 이라는 새로운 API를 제공한다.

고수준 언어로 원하는 동작을 표현하면, 구현(스트림 라이브러리)에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작하게된다. 

즉 스트림을 이용하면, 멀티코어 CPU를 이용하는 것보다 비용이 비싸면서 에러를 자주 발생시키기도 하는 synchronized 키워드를 사용하지 않아도 된다.

조금 다른 관점에서 바라보면, 결국 자바 8에 추가된 스트림 API 덕분에 다른 두 가지 기능, 즉 **메소드에 코드를 전달하는 간결 기법(메소드 참조와 람다)과 인터페이스의 디폴트 메소드**가 존재할 수 있음을 알 수 있다.

<br>

## 1.2 왜 아직도 자바는 변화하는가?

1960년대에 사람들은 완벽한 프로그래밍 언어를 찾고자 노력했다. 그에 따라 세상에는 수많은 프로그래밍 언어가 쏟아져 나왔으며, 이 때 새로운 언어들이 등장함에 따라 진화하지 않은 기존 언어는 사장되었다.

하지만, **"NO SILVER BULLET -  은총알(세상에 완벽한 해결책)은 없다”** 라는 말이 있는 것처럼. 현실적으로 완벽한 언어는 존재하지 않으며, 모든 언어가 장단점을 갖는다.

예를 들어 C, C++는 프로그래밍 안정성은 부족하지만, 작은 런타임 풋프린트 덕분에 운영체제와 다양한 임베디드 시스템에서 여전히 인기를 끌고있다. 하지만 낮은 안정성에 의해 프로그램이 예기치 않게 종료되거나 바이러스등이 침투하는 등의 보안 구멍이 존재한다.

이렇듯 완벽한 언어가 존재하지 않다보니 특정 분야에 장점을 가진 언어가 등장하게 되면, 다른 경쟁 언어들은 도태되기 마련이다. 

그렇기에 자바는 도태되지 않기 위해, 변화하는 환경에 빠르게 적응하면서 계속해서 변해간다.

자바는 자바 8을 맞이하면서 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며, 쉽게 유지보수할 수 있도록 변화하였다.

이러한 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념에 대해 짚고 넘어가자.

<br>

### **스트림 처리**

**스트림이란?**

> **한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임**
> 

이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

자바 8에는 [java.util.stream](http://java.util.stream) 패키지에 스트림 API가 추가되었다. 스트림 패키지에 정의된 Stream<T>는 T 형식으로 구성된 일련의 항목을 의미한다. 

우선은 Stream API가 **어떤 항목을 연속으로 제공하는 어떤 기능** 이라고 단순하게 생각하고 넘어가자.

스트림 API의 핵심은, 기존에는 한 번에 한 항목을 처리했지만, 자바 8에서는 우리가 하려는 작업을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다.

또한 스트림 파이프라인을 통해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있으며, 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

<br>

### 동작 파라미터화로 메소드에 코드 전달하기

자바 8에 추가된 두 번째 프로그래밍 개념은, **코드 일부를 API로 전달하는 기능**이다. 

코드 측면에서 말하자면, **메소드를 다른 메소드의 인수로 넘겨주는 기능을 제공**한다는 것이다. 

이러한 기능을 이론적으로 **동작 파라미터화** 라고 부른다.

이는, **메소드라는 ‘동작’ 을 인수로 넘겨주기 위해 ‘파라미터화’ 를 수행한다고 이해**하면 된다.

<br>

### 병렬성과 공유 가변 데이터

세 번째 프로그래밍 개념은, **“병렬성을 공짜로 얻을 수 있다”** 라는 말에서 시작한다. 모든 기능에는 항상 트레이드 오프가 존재한다는 말을 많이 들어보았을 것이다.

그럼 병렬성을 공짜로 얻는 대신에 무엇을 포기해야할까? 우선 **스트림 메소드로 전달하는 코드의 동작 방식을 바꾸어야한다**. 

스트림 메소드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야한다. 보통 다른 코드와 동시에 실행하더라도 **안전하게 실행**할 수 있는 코드를 만들기 위해서는, **공유된 가변 데이터에 접근하지 않아야한다.** 

어찌보면 당연하다. 공유되면서 동시에 가변 상태라면, 여러 사람이 동시에 해당 데이터를 조작했을 때 원하는 형태의 데이터를 얻지 못하게될 가능성이 다분하기 때문이다.

이렇듯 공유된 가변 데이터에 접근하지 않는 함수를 **순수 함수, 부작용 없는 함수, 상태 없는 함수** 등으로 부른다.

자바 8 이전에는 synchronized 키워드를 사용함으로써 공유된 가변 데이터를 보호하는 규칙을 만들어 사용하였다. 문제는 이 synchronized 키워드가 일반적으로 시스템 성능에 악영향을 미친다는 것이다.

하지만 자바 8의 스트림을 이용하면, 기존의 자바 스레드 API 보다 더 쉽게 병렬성을 활용할 수 있다. 

공유되지 않은 가변 데이터, 메소드, 함수 코드를 다른 메소드로 전달하는 두 가지 기능은 **함수형 프로그래밍** 패러다임의 핵심적인 사항이다. 

기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다는 것이 자바 8의 가장 큰 변화라고 볼 수 있다.

함수형 프로그래밍에서는 우리가 하려는 작업이 최우선시 되며, 그 작업을 어떻게 수행하는지는 별개의 문제로 취급한다.

극단적으로 생각해보면 사실 전통적인 객체지향 프로그래밍과 함수형 프로그래밍은 완전 상극이다. 그러다보니 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있게 되었다.

<br>

## 1.3 자바 함수

프로그래밍 언어에서 **함수** 라는 용어는 **메소드**, 특히 정적 메소드와 같은 의미로 사용된다.

자바의 함수는 이에 더해 **수학적인 함수**처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.

자바 8에서는 함수를 새로운 값의 형식으로 추가했다. 스트림과 연계될 수 있도록 하기 위해 함수를 만들었기 때문이다. 함수를 값으로 취급하기 시작한다면, 이를 통해 어떠한 이점을 얻을 수 있을까?

우선 자바에서 조작할 수 있는 값들을 생각해보자. 우선 12(int 형식), 3.14(double 형식) 과 같은 기본값이 있으며, 두번째로 객체(엄밀히 말하자면 객체의 참조)도 값으로 간주한다. 이 때 new 또는 팩토리 메소드, 라이브러리 함수들을 통해 객체의 값을 얻을 수 있다. 

그런데도 왜 함수가 필요한걸까?

프로그래밍 언어에서의 핵심은 값을 바꾸는 것이다. 프로그래밍 언어에서는 이 값을 **일급 값(OR 시민)** 으로 부른다.
<br>

<aside>

❗️**일급 시민**

1. **변수에 담을 수 있다.**
2. **함수의 인자로 전달할 수 있다.**
3. **함수의 반환값으로 전달할 수 있다.**

→ 이 3가지 기준을 충족하는 것

</aside>
<br>

자바 프로그래밍 언어에서는 메소드나 클래스와 같은 다양한 구조체가 값의 구조를 표현하는데 도움이 될 수 있다. 하지만 프로그램을 실행하면서, 이러한 모든 구조체들을 자유롭게 전달할 수는 없다.

이렇듯 전달할 수 없는 구조체는 **이급 시민**이다. 

앞서 언급한 12, 3.14, 객체 등등은 모두 일급 시민이지만, 메소드, 클래스 등은 이급 시민에 해당한다.

이 때 메소드를 일급 시민으로 만들게 된다면, 즉 전달할 수 있는 형태로 바꾸게 된다면 프로그래밍에 더 유용하게 사용할 수 있지 않을까? 하는 생각이 들 수 있는데, 그것을 실현으로 옮긴 것이 자바 8 설계자들이다. 즉 **자바 8에는 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가되었다.**

<br>

### 메소드와 람다를 일급 시민으로

자바 8의 설계자들은 메소드를 값으로 취급할 수 있도록 자바를 진화시키고자 하였고, 이는 스트림과 같은 다른 자바 8 에서 제공하는 기능들의 토대를 제공한다.

<br>

**메소드 참조** 

자바 8에서 제공하는 새로운 기능인 메소드 참조에 대해 알아보자.

디렉토리에 존재하는 모든 숨겨진 파일을 필터링한다고 가정해보자. 이 때 우선 주어진 파일이 숨겨져 있는지 여부를 알려주는 메소드를 구현해야한다. 이 때 File 클래스는 isHidden 메소드를 제공하는데, 이 isHidden 메소드는 File 클래스를 인수로 받아 boolean 을 반환하는 메소드이다.

다음 예시 코드처럼 FileFilter 객체 내부에 위치한 isHidden 의 결과를 File.listFiles 메소드로 전달하는 방법을 통해 숨겨진 파일을 필터링할 수 있다.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
		public boolean accept(File file) {
				return file.isHidden();
		}
});
```
<img width="515" alt="스크린샷_2025-03-26_오후_9 22 56" src="https://github.com/user-attachments/assets/93cfc2e3-a780-4059-a6e5-05db33823b13" />

다만 이 코드는 별로 보기 좋지 않다. 단 세 행의 코드이지만 각 행이 무슨 작업을 하는지 투명하지 못하다.

이미 File 클래스에는 isHidden 메소드가 존재하는데, 굳이 FileFilter 로 isHidden 을 복잡하게 감싸고 FileFilter를 인스턴스화 해야하는걸까? ( = 객체 참조)

더 나은 방법은 없을까? 사실 자바 8 이전까지는 별다른 방법이 없었다.

그럼 자바 8에서는 어떤 식으로 코드를 구현할 수 있을까?

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

<img width="501" alt="스크린샷_2025-03-26_오후_9 23 19" src="https://github.com/user-attachments/assets/92984bdb-c642-48d2-88f1-021e3616ecf9" />

코드가 아주 간결해졌고 매우 직관적이어졌다.

이미 isHidden 이라는 함수가 준비되어있기 때문에 **자바 8의 메소드 참조 (이 메소드를 값으로 사용하라는 의미)** 를 이용해서 listFiles 에 함수를 직접 전달할 수 있다. (메소드가 아니라 함수라고 명명한 것에도 주목하자)

이제 확실하게 알 수 있다. 자바 8에서는 더이상 메소드가 이급 값이 아닌 일급 값인 것이다. **기존에 객체 참조(new 를 통해 객체 참조를 생성) 를 이용해서 객체를 이리저리 주고 받을 필요 없이, 간단하게 메소드 참조를 만들어 전달할 수 있게된 것**이다.

메소드는 코드를 포함하고있기 때문에 사실상 코드를 마음대로 전달할 수 있게되었다다고 볼 수 있다.

<br>

**람다 : 익명 함수**

자바 8에서는 (기명) 메소드를 일급값으로 취급할 뿐 아니라, 람다(또는 익명 함수) 를 포함하여 함수도 값으로 취급할 수 있다.

예를 들어 **`(int x) → x + 1`** 처럼 x 라는 인수를 넘겨주면 x + 1 을 반환하는 동작을 수행하도록 코드를 구현할 수 있다.

그럼 이 때 이런 의문이 들 수 있다. MathUtil 이라는 클래스를 만들어서 내부에 add() 라는 static 메소드를 만들어두면, **`MathUtil::add`** 와 같이 메소드 참조를 사용할 수도 있을텐데, 굳이 이런 익명 함수가 왜 필요한 것일까?

물론 이와 같은 형태로도 구현이 가능한 것은 맞다. 하지만 이용할 수 있는 편리한 클래스나 메소드가 존재하지 않을 때에는 새로운 람다 문법을 이용하면 더 간단하게 코드를 구현할 수 있다.

**람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 ‘함수를 일급값으로 넘겨주는 프로그램을 구현한다’ 라고 이야기한다.**

<br>

### 코드 넘겨주기 - 예제

Student 클래스와 getGrade 메소드가 있고, Student 리스트를 포함하는 변수 students 가 있다고 가정하자. 

이 때 성적이 A인 모든 학생을 선택해서 리스트로 반환하는 프로그램을 구현하려한다. 이처럼 특정 항목을 선택해서 반환하는 동작을 **필터** 라고 한다. 자바 8 이전에는 아래와 같이 메소드를 구현해야했다.

```java
public static List<Student> filterAGradeStudents(List<Student> students) {
		List<Student> result = new ArrayList<>();
		
		for(Student student : students) {
				if (A.equals(student.getGrade())) { <-----
						result.add(student);
				}
		}
		return result;
}
```

하지만 이 때 누군가는 학생들을 성적이 아니라 학번으로 필터링하고 싶어할 수도 있다. 그러면 우리는 다음과 같이 코드를 수정할 것이다.

```java
public static List<Student> filterStudentsByLowId(List<Student> students) {
		List<Student> result = new ArrayList<>();
		
		for(Student student : students) {
				if (student.getStudentId() < 202000000)) { <-----
						result.add(student);
				}
		}
		return result;
}
```

이 코드의 로직은 화살표로 표시된 부분을 제외하고는 모두 동일한 로직을 갖는다. 그럼에도 불구하고 세부 로직을 원하는 대로 갈아끼우지 못하기에 복사 붙여넣기를 통해 대부분의 로직을 복사하고, 세부 로직만 고쳐서 새로운 filter 메소드를 만들어낸다. 오직 한 줄의 코드 때문에 이러한 동작을 해야하는 것이다.

하지만 자바 8에서는 어떨까? 자바 8에서는 코드를 인수로 넘겨줄 수 있다. 따라서 filter 메소드를 중복으로 구현할 필요가 없어진다.

```java
public static boolean isAGradeStudent(Student student) {
		return A.equalst(student.getGrade());
}

public static boolean isLowIdStudent(Student student) {
		return student.getStudentId() < 202000000;
}

public interface Predicate<T> {
		boolean test(T t);
}

static List<Student> filterStudents(List<Student> students, Predicate<Student> p) {
		List<Student> result = new ArrayList<>();
		
		for(Student student : students) {
				if(p.test(student)) {
						result.add(student);
				}
		}
		return result;
}
```

<br>

<aside>

❗️**프레디케이트 (Predicate) 란 무엇인가?**

**수학에서는 인수로 값을 받아 true 나 false 를 반환하는 함수를 프레디케이트 라고 한다.** 

**자바에서도 마찬가지로 인수로 어떠한 값을 받아 true 나 false 를 반환하는 함수를 프레디케이트라고 칭한다.**

</aside>

<br>

이렇게 세부 로직을 구현할 수 있다. 이를 통해 filter 메소드를 여러 개 만들면서 볼륨을 키울 필요 없이, 세부 로직을 구현한 메소드만 인수로 넘겨주면서 구현을 변경할 수 있는 것이다.

실제 메소드 호출은 다음과 같다.

```java
filterStudents(students, Student::isAGradeStudent);

filterStudents(students, Student::isLowIdStudent);
```

<br>

### 메소드 전달에서 람다로

위의 예시처럼 메소드를 값으로 전달하는 것은 분명 유용한 기능이다. 하지만 isAGradeStudent, isLowIdStudent 처럼 한 두번만 사용할 메소드를 매번 정의하는 것은 귀찮다. (물론 자주 재사용되는 메소드의 경우 구현해두는 것이 유용하다.)

따라서 자바 8에서는 람다 (익명 함수) 라는 새로운 개념을 이용하여 코드를 구현할 수 있다.

```java
filterStudents(students, (Student s) -> A.equals(s.getGrade()) );

filterStudents(students, (Student s) -> s.getStudentId() < 202010000 );
```

즉 이처럼 한 두번 사용하고 말 메소드는 따로 정의를 구현할 필요없이 간편하게 사용하고 버리면 된다.

**하지만 람다식이 몇 줄 이상으로 길어진다면 ( = 조금 복잡한 동작을 수행하는 상황) 익명 람다보다는, 코드가 수행하는 일을 잘 설명하는 이름을 갖는 메소드를 정의하고, 메소드 참조를 활용하는 것이 바람직하다.**

**코드의 명확성이 우선시되어야한다!!**

<br>

## 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 **만들고 활용**한다. 하지만 컬렉션을 활용한다고 해서 모든 문제가 해결되는 것은 아니다.

**컬렉션 API**에서는 반복 과정을 개발자가 직접 처리해야한다. 즉 for-each 루프를 이용해서 각 요소를 반복하며 작업을 수행해주어야하는 것이다.

이런 방식의 반복을 **외부 반복** 이라고 한다.

반면 **스트림 API** 를 사용하면 루프를 개발자가 신경 쓸 필요가 없어진다.

스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 

이런 방식의 반복을 **내부 반복** 이라고 한다.

<br>

**멀티 스레딩**

자바 8 이전의 자바에서 병렬성을 확보하기 위해서는, 스레드 API 를 통한 멀티스레딩 코드를 구현하여야 했다.

멀티스레딩 환경에서는 각각의 스레드가 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다. 결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있는 것이다. 

즉 **race condition 발생 가능성을 내포**하고있다.

<img width="524" alt="스크린샷_2025-03-26_오후_9 53 10" src="https://github.com/user-attachments/assets/68d9e177-cb11-47f9-8d4f-79a10e68219f" />

→ 스레드 1은 기존의 값에 3을 더하고, 스레드 2는 기존의 값에 5를 더함으로써 최종 결과가 108이 도출되어야하는데, 공유된 데이터에 접근하다보니 race condition 이 발생하여 105 라는 결과가 도출되는 상황

반면에 자바 8은 스트림 API 를 통해 ‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’ 그리고 ‘멀티코어 활용 어려움’ 이라는 두 가지 문제를 모두 해결했다. 

기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았다. 

- 데이터를 필터링
- 데이터를 추출
- 데이터를 그룹화

등등의 반복적인 패턴들이 많았는데, 스트림은 이러한 반복되는 패턴을 라이브러리 차원에서 제공한다. 또한 이러한 동작들을 간편하게 병렬화해준다.

스트림은 스트림 내의 요소들을 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심이다.

```java
// 순차 처리
List<Student> aGradeStudents = students.stream()  <-----
				.filter((Student s) -> A.equals(s.getGrade))
				.collect(toList());				
									
// 병렬 처리								
List<Student> aGradeStudents = students.parallelStream()  <-----
				.filter((Student s) -> A.equals(s.getGrade))
				.collect(toList());
```
<br>
<aside>

❗️**컬렉션은 데이터를 어떻게 저장하고 접근할 지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다는 것을 기억하자!**

</aside>
<br>

## 1.5 디폴트 메소드와 자바 모듈

자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로, 이를 이용해 패키지 모음을 포함하는 **모듈**을 정의할 수 있다.

또한 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메소드를 지원한다.

사실 이 디폴트 메소드를 프로그래머가 직접 구현하는 상황은 흔치 않다. **디폴트 메소드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라, 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.**

그럼 어떤 식으로 프로그램이 쉽게 변화할 수 있는 환경을 제공한다는 것일까?

디폴트 메소드가 존재하지 않을 때 발생할 수 있는 상황을 생각해보자. 

만약 인터페이스에 새로운 메소드를 추가해야하는 상황이 생겼는데, 이미 해당 인터페이스를 구현해놓은 구현 클래스가 많이 존재하고 있다면 어떻게 해야할까? 그 수많은 구현 클래스들 각각에서 새롭게 추가된 메소드를 구현해주어야한다.

심지어 이 인터페이스가 자바 설계자들이 만들어놓은 인터페이스였다면? 예를 들어 Collection 같은 인터페이스에 새로운 메소드가 추가되어야하는 것이다. 이 때 무작정 자바 설계자들이 인터페이스에 메소드를 추가하게되면, 해당 인터페이스를 가져다가 별도의 구현 클래스를 만들어서 사용하던 프로그래머들은 그 스펙에 맞게 모두 해당 메소드를 구현해주어야만 한다.

현실적으로 이 설계자들이 모든 구현 클래스들의 코드를 책임져줄 수는 없다. 여기서 딜레마에 빠진다. 

**어떻게 기존의 구현을 고치지 않고도 이미 공개되어있는 인터페이스를 변경할 수 있을까?**

자바 8은 구현 클래스에서 구현하지 않아도 되는 메소드를 인터페이스에 추가할 수 있는 기능을 제공한다. 

**메소드의 body 부분은, 클래스의 구현이 아니라 인터페이스의 일부로써 포함된다. 그래서 이를 디폴트 메소드라고 부른다.**

이 디폴트 메소드를 이용하면 기존의 코드를 건드리지 않고도 공개되어있는 인터페이스의 설계를 자유롭게 확장할 수 있다.

자바 8에서는 인터페이스 규격 명세에 **default** 라는 새로운 키워드를 지원한다.

```java
// List
default void sort(Comparator<? super E> c) {
		Collections.sort(this, c);
}
```

<br>

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

일반적인 함수형 언어도 프로그램을 돕는 여러 장치를 제공하는데, 일례로 바로 서술형의 데이터 형식을 이용하여 null 을 회피하는 기법이 있다.

자바 8에서는 이와 유사하게 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공한다.

**Optional<T> 는 값을 갖거나, 갖지 않을 수 있는 컨테이너 객체**이다. Optional<T> 는 값이 없는 상황을 어떻게 처리할 지 명시적으로 구현하는 메소드를 포함한다. 그에 따라 이를 활용하면 NullPointer 예외를 피할 수 있다.
