# 13장 디폴트 메소드

# 13.3 디폴트 메서드 활용 패턴

외부에 공개한 라이브러리에서 새로운 기능을 추가하기 위해서 디폴트메서드를 사용할 수 있다는 것을 앞에서 배웠다.

그렇다면 우리가 사용하기 위해 만든 인터페이스에서는 디폴트 메서드를 어떻게 활용할 수 있을까?

여기서는 디폴트 메서드를 활용하는 다음 두 가지 방식에 대해서 배운다.

1. 선택형 메서드
2. 동작 다중 상속

## 13.3.1 선택형 메서드

어쩌면 인터페이스를 구현하는 클래스에서 메서드의 내용이 비어 있는 상황을 본적이 있을 수 있다.

대표적인 사례가 Iterator를 구현하는 클래스이다.

- Iterator 인터페이스는 hasNext, next 그리고 remove 메서드를 정의한다.
- 그런데 사용자들이 remove 메서드를 잘 사용하지 않으므로 remove 기능을 제공하지 않았다. 즉 Iterator 인터페이스를 구현하는 많은 클래스에서 remove에 빈 구현을 제공했다.
- 그런데 이렇게 하면 Iterator를 구현하는 많은 클래스에서 비어 있는 내용을 구현해야 한다는 번거로움이 있다.

디폴트 메서드를 이용하면 remove 같은 메서드에 기본 구현을 제공할 수 있으므로 인터페이스에서 처음부터 비어 있는 구현을 제공할 수 있다. 

예를 들어서 자바 8부터 Iterator 인터페이스에서 remove를 다음과 같이 제공한다.

```java
interface Iterator<T> {
	boolean hasNext();
	T next();
	default void remove() {
		throw new UnsupportedOperationException()； // 예외를 발생시키는 빈 구현
	}
}
```

## 13.3.2 동작 다중 상속

디폴트 메서드를 이용하면 기존에는 불가능했던 동작 다중상속 기능도 구현할 수 있다. 클래스는 다중 상속을 이용해서 기존 코드를 제사용할 수 있다.

자바에서 클래스는 하나의 다른 클래스만 상속받을 수 있지만, 인터페이스는 여러개 구현할 수 있다.

예를 들어서 ArrayList를 보자

```java
public class ArrayList<E> extends AbstractList<E>
	implements List<E>, RandomAccess, Cloneable,Serializable { 

}
```

- ArrayList는 한 개의 클래스와 여섯개의 인터페이스를 구현하게 된다. 따라서 디폴트 메서드가 없어도 다중상속을 활용할 수 있기는 하다.
- 그런데 자바 8부터는 인터페이스가 디폴트 메소드를 제공하므로 클래스가 여러 인터페이스로부터 동작, 즉 구현 코드를 상속 받을 수 있다!

기능이 중복되지 않는 최소한의 인터페이스를 유지할 수 있다면 우리 코드에서 동작을 쉽게 재사용하고 조합할 수 있다.

동작 다중상속의 방법은 다음과 같다.

1. 기능이 중복되지 않는 최소한의 인터페이스를 정의한다
2. 이들을 조합해서 구현 클래스를 만든다

이렇게만 보면 잘 와닿지 않으니 예시를 통해서 알아보자. 

예를 들어서 우리가 게임을 만들고 있고, 여기서 우리는 여러 특성을 가지고 있는 다양한 모양 객체를 만들어야 한다고 하자.

- 어떤 모양은 회전할 수 없지만 크기를 조정할 수 있고, 어떤 모양은 회전할 수 있지만 크기를 바꿀 수는 없다.

최대한 기존 코드를 재사용해서 이 기능을 구현하려면 어떻게 해야할까? 

먼저 회전과 관련된 기능을 정의하는 Rotatable 인터페이스를 정의해볼 수 있다.

- 이 인터페이스는 두 개의 추상메서드 setRotationAngle과 getRotationAngle를 제공한다.
- 또한 위 두개의 추상메서드를 가지고 디폴트 메서드 rotateBy를 구현한다.

```java
public interface Rotatable {
	void setRotationAngle(int anglelnDegrees);
	
	int getRotationAngle();
	
	default void rotateBy(int anglelnDegrees) { 
		setRotationAngle((getRotationAngle () + anglelnDegrees) % 360);
	}
}
```

- 위 인터페이스는 구현해야할 메서드에 따라서 뼈대 알고리즘(여기서는 디폴트 메서드가 이에 해당)이 결정되는 템플릿 디자인 패턴과 유사하다.
- 어쨌든 여기서는 rotateBy의 기본 구현이 제공되므로 구현 클래스에서는 따로 구현할 필요가 없다.

마찬가지 방식으로 이동과 크기 조절과 관련된 두 인터페이스 Moveable과 Resizable을 정의할 수 있다. 두 인터페이스 모두 디폴트 구현을 제공한다.

```java
public interface Moveable {
	int getX();
	int getY();
	void setX(int x);
	void setY(int y);
	
	defauIt void moveHorizontally(int distance){
		setX(getX() + distance);
	}
	
	default void moveVertically(int distance){
		setY(getY() + distance);
	}
}

public interface Resizable {
	int getWidth();
	int getHeight();
	void setWidth(int width);
	void setHeight(int height);
	void setAbsoluteSize(int width, int height);
	
	default void setRelativeSize(int wFactor, int hFactor){
		setAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);
	}
}
```

이제 이 인터페이스들을 조합해서 다양한 클래스를 구현할 수 있다.

- 예를 들어서 괴물 객체를 만들어야 한다. 괴물은 움직일 수 있고, 회전할 수도 있고, 심지어 크기도 바꿀 수 있다.
- 그렇다면 괴물을 나타내는 클래스 Monster는 다음과 같이 구현할 수 있다.

```java
public class Monster implements Rotatable, Moveable, Resizable {
}
```

- Monster 클래스는 **Rotatable, Moveable, Resizable** 인터페이스의 디폴트 메서드를 자동으로 상속받는다.
- 상속받은 메서드를 직접 호출 할 수 있다.

```java
Monster m = new Monster()；

m.rotateBy(180);         // 180도 회전
m.moveVertically(10);    // 수직으로 10 이동
```

이렇게 하면 디폴트 메서드를 재사용하기 때문에 중복되는 코드를 작성할 필요가 전혀 없다!

또한 디폴트 메서드를 변경하면 여러 구현 클래스에도 자동으로 변경을 적용할 수도 있다는 장점이 있다.

- 예를 들어서 moveVertically 메서드의 구현을 더 효율적으로 고친다면, 디폴트 메서드 덕분에 Moveable을 구현하는 모든 클래스도 자동으로 변경된 코드를 상속받게 된다.

> [!TIP] 옳지 못한 상속
> 
> 상속으로 모든 코드 재사용 문제를 해결할 수 있지는 않다.
> 
> - 예를 들어서 한개의 메서드를 재사용하려고 100개의 메서드와 필드가 정의된 클래스를 상속받는 것은 좋은 생각이 아니다.
> - 이 때는 델리게이션을 이용해야 한다. 즉 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성해야 한다.
> - 디폴트 메소드를 이용하여 기능 다중 상속을 제공하고 싶다면, 인터페이스를 최소한으로 유지하자

# 13.4 해석 규칙

자바의 클래스는 하나의 여러 인터페이스를 구현할 수 있다. 이때 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 발생할 수 있다. 이 경우에 클래스는 어떤 인터페이스의 디폴트 메서드를 사용할까?

이를 해결하기 위한 규칙이 필요하다.

다음 코드를 통해 알아보자. (자주 발생하는 상황은 아니긴 하다)

```java
public interface A {
	default void hello() { 
		System.out.printin("Hello from A"); }
	}

public interface B extends A {
	default void hello() {
		System.out.println("Hello from B");
	}
}

public class C implements B, A {
	public static void main(String... args) {
		new C().hello(); // 여기서 무엇이출력될까?
	}
	
}
```

- 이 문제는 C++의 다이아몬드 문제와 닮았다.
- 이때 어떤 메서드를 사용할까?

자바8은 이러한 문제에 대한 해결 규칙을 제공한다!

## 13.4.1 알아야 할 세 가지 해석 규칙

다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속 받을 때는 세가지 규칙을 따라야 한다.

1. 클래스가 항상 이긴다. 클래스나 슈퍼 클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 규칙 이외의 상황에서는 서브 인터페이스가 이긴다. 같은 시그니처를 가지는 디폴트 메서드 중에서 서브 인터페이스의 메서드가 선택된다.
3. 여전히 디폴트 메서드의 우선순위가 정해지지 않았다면, 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드해서 호출해서 디폴트 메서드를 선택해야 한다.

## 13.4.2 디폴트 메서드를 제공하는 서브 인터페이스가 이긴다

이 규칙을 가지고 다시 예제를 보자

![image.png](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%B5%E1%84%91%E1%85%A9%E1%86%AF%E1%84%90%E1%85%B3%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A9%E1%84%83%E1%85%B3%201fd2dcb5a74a80c39015e1bf0897d457/image.png)

- 클래스 B와 A는 hello 디폴트 메서드를 정의한다. 또한 B는 A를 상속받는다.
- 따라서 컴파일러는 2번 규칙에 의해서 서브인터페이스인 B의 hello를 선택한다.

이번에는 다음 UML 다이어그램과 같은 상황이라고 하자.

![image.png](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%B5%E1%84%91%E1%85%A9%E1%86%AF%E1%84%90%E1%85%B3%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A9%E1%84%83%E1%85%B3%201fd2dcb5a74a80c39015e1bf0897d457/image%201.png)

```java
public class D implements A{ }

public class C extends D implements B, A {	
	public static void main(String... args) {
		new C().hello(); //  무엇이출력될까?
	}
}
```

- 첫번째 규칙에 의하면 클래스의 메서드가 이긴다. 그런데 클래스 D는 메서드를 오버라이드 하진 않으므로 A의 디폴트 메서드를 상속받는다. 그러므로 첫번째 규칙에는 해당하지 않는다.
- 두번째 규칙에 의하면 서브 인터페이스의 디폴트 메서드가 선택된다. 인터페이스 B는 A의 서브타입이고 디폴트 메서드를 오버라이드한다. 따라서 두번째 규칙에 해당하는 상황이고 컴파일러에 의해서 B가 A의 서브 타입이니 B의 hello가 선택된다.

## 13.4.3 충돌 문제 해결

이번에는 B가 A를 상속받지 않는 상황이라고 하자

![image.png](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%B5%E1%84%91%E1%85%A9%E1%86%AF%E1%84%90%E1%85%B3%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A9%E1%84%83%E1%85%B3%201fd2dcb5a74a80c39015e1bf0897d457/image%202.png)

```java
public interface A {
	default void hello() {
		System.out.println("Hello from A");
	}
}
public interface B {
	default void hello() {
		System.out.println("Hello from B");
	}
}
```

이 때 C의 hello를 호출하면 어떻게 될까?

- 인터페이스간의 상속 관계는 없으므로 2번 규칙은 적용할 수 없다. 그러므로 A와 B의 hello 메서드를 구분할 수 없다.
- 따라서 자바 컴파일러는 에러를 발생시킨다.

```java
“Error： class C inherits unrelated defaults for hello( ) from types B and A.”
```

클래스와 메서드 사이의 관계로 디폴트 메서드를 선택할 수 없는 상황에서는 개발자가 직접 사용하려는 메서드를 명시적으로 선택해야 한다.

- 예시로 다시 돌아가보면 클래스 C는 hello 메서드를 오버라이드 한 다음에 어떤 디폴트 메서드를 호출할 것인지 명시적으로 선택해야 한다.
- 자바 8에서는 `X.super.m()` 형태의 새로운 문법을 제공한다.
    - X는 인터페이스이고, m은 호출할 메서드이다.
- C에서 B의 hello 메서드를 호출하고 싶다면 다음과 같다.

```java
public class C implements B, A {
	void hello(){
		B.super.hello(); 
	}
}
```

## 13.4.4 다이아몬드 문제

마지막으로 다음 시나리오를 보자

```java
public interface A {
	default void hello(){
		System.out.println("Hello from A");
	}
}
public interface B extends A { }
public interface C extends A { }

public class D implements B, C {
	public static void main(String... args) {
		new D().hello();
	}
}
```

이 상황을 다이어그램으로 나타내면 다음과 같다.

![image.png](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%B5%E1%84%91%E1%85%A9%E1%86%AF%E1%84%90%E1%85%B3%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A9%E1%84%83%E1%85%B3%201fd2dcb5a74a80c39015e1bf0897d457/image%203.png)

다이어그램이 다이아몬드를 닮았다하여 이를 다이아몬드 문제라고 한다.

D는 B와 C 중 어떤 디플트 메서드 정의를 상속 받을까? A만 디폴트 메서드를 정의하고 있으므로 출력은 “Hello from A”일 것이다.

만약 B에 같은 시그니처의 디폴트 메서드 hello가 있다면 어떻게 될까?

- 2번 규칙에 따르면 서브 인터페이스의 디폴트 메서드가 선택된다. 따라서 B의 hello가 선택된다.

만약 B와 C에 같은 시그니처의 디폴트 메서드 hello가 있다면 어떻게 될까?

- 충돌이 발생하므로 D에서는 두 디폴트 메서드 중 하나를 명시적으로 선택해야 한다.

그렇다면 C에 hello라는 추상 메서드가 있다면 어떻게 될까?

```java
public interface C extends A {
	void hello();
}
```

- C는 A의 상속 받으므로 C의 hello가 A의 hello보다 우선권을 갖는다.
- 따라서 컴파일 에러가 발생하며 클래스 D가 어떤 hello를 사용할지 명시적으로 선택해서 에러를 해결해야 한다.

> [!TIP] C++의 다이아몬드 문제
>
> C++의 다이아몬드 문제는 이보다 더 복잡하다. 
>
> 우선 C++는 **클래스의 다중 상속**을 지원한다
>
> - 클래스 D가 클래스B와 C를 상속받고 B와 C는 클래스 A를 상속받는다고 가정하자
> - 그러면 클래스 D는 B 객체와 C 객체의 복사본에 접근할 수 있다
> - 결과적으로 A의 메서드를 사용할 때 B의 메서드인지 C의 메서드인지 명시적으로 해결해야 한다
> 또한 클래스는 상태를 가질 수 있으므로 B의 멤버 변수를 수정해도 C 객체의 복사본에 반영되지 않는다
> 참고로 C++에서는 이런 문제를 해결하기 위해서 가상상속을 이용한다.

```java
class A {
public:
    void someMethod();
};

class B : public A{};

class C : public A{};

class D : public B, public C {};

d.someMethod(); // 어떤 someMethod()인지 모르니 에러 발생!
```

```java
class A {
public:
    int value;
};

D d;
d.B::value = 10;
std::cout << d.C::value; // C의 값이 바뀌지 않는다!
```
